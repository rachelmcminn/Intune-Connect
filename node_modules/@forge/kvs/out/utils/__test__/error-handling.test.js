"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../../errors");
const error_handling_1 = require("../error-handling");
describe('error-handling', () => {
    it('isForgeError', () => {
        expect((0, error_handling_1.isForgeError)({ code: 'code', message: 'message' })).toBe(true);
        expect((0, error_handling_1.isForgeError)({ code: 'code' })).toBe(false);
        expect((0, error_handling_1.isForgeError)({ message: 'message' })).toBe(false);
        expect((0, error_handling_1.isForgeError)({})).toBe(false);
        expect((0, error_handling_1.isForgeError)(null)).toBe(false);
        expect((0, error_handling_1.isForgeError)(undefined)).toBe(false);
        expect((0, error_handling_1.isForgeError)('string')).toBe(false);
        expect((0, error_handling_1.isForgeError)(123)).toBe(false);
    });
    it('safeGetParsedBody', () => {
        expect((0, error_handling_1.safeGetParsedBody)('{"valid": "json"}')).toEqual({ valid: 'json' });
        expect((0, error_handling_1.safeGetParsedBody)('invalid json')).toBeUndefined();
    });
    describe('checkResponseError', () => {
        const traceId = 'trace-id';
        it('should do nothing if response is ok', async () => {
            const mockResponse = new Response('OK', {
                status: 200,
                statusText: 'OK'
            });
            await expect((0, error_handling_1.checkResponseError)(mockResponse)).resolves.toBeUndefined();
        });
        describe('Forge errors - ForgeKvsAPIError', () => {
            const message = 'A test error has occurred';
            const code = 'ERROR_CODE';
            it('should return a ForgeKvsAPIError when response body is a Forge error', async () => {
                const mockResponse = new Response(JSON.stringify({ code, message }), {
                    status: 400,
                    statusText: 'Bad Request',
                    headers: { 'x-trace-id': traceId }
                });
                await expect(async () => await (0, error_handling_1.checkResponseError)(mockResponse)).rejects.toMatchError(new errors_1.ForgeKvsAPIError({
                    status: 400,
                    statusText: 'Bad Request',
                    traceId
                }, { code, message }));
            });
            it('should include context if present in the Forge error', async () => {
                const context = { key: 'value' };
                const mockResponse = new Response(JSON.stringify({ code, message, context }), {
                    status: 400,
                    statusText: 'Bad Request',
                    headers: { 'x-trace-id': traceId }
                });
                await expect(async () => await (0, error_handling_1.checkResponseError)(mockResponse)).rejects.toMatchError(new errors_1.ForgeKvsAPIError({
                    status: 400,
                    statusText: 'Bad Request',
                    traceId
                }, { code, message, context }));
            });
            it('should include top level additional fields if present in the Forge error', async () => {
                const extraFields = { extraValue: 'value', debug: true };
                const mockResponse = new Response(JSON.stringify({ code, message, ...extraFields }), {
                    status: 400,
                    statusText: 'Bad Request',
                    headers: { 'x-trace-id': traceId }
                });
                await expect(async () => await (0, error_handling_1.checkResponseError)(mockResponse)).rejects.toMatchError(new errors_1.ForgeKvsAPIError({
                    status: 400,
                    statusText: 'Bad Request',
                    traceId
                }, { code, message, context: extraFields }));
            });
            it('should merge context and additional top level fields if both present in the Forge error', async () => {
                const context = { key: 'value' };
                const extraFields = { extraValue: 'value', debug: true };
                const mockResponse = new Response(JSON.stringify({ code, message, context, ...extraFields }), {
                    status: 400,
                    statusText: 'Bad Request',
                    headers: { 'x-trace-id': traceId }
                });
                await expect(async () => await (0, error_handling_1.checkResponseError)(mockResponse)).rejects.toThrowError(new errors_1.ForgeKvsAPIError({
                    status: 400,
                    statusText: 'Bad Request',
                    traceId
                }, { code, message, context: { ...context, ...extraFields } }));
            });
            describe('Handle non forge errors', () => {
                it('returns an UNKNOWN_ERROR when no response body', async () => {
                    const mockResponse = new Response(undefined, {
                        status: 404,
                        statusText: 'Not Found',
                        headers: { 'x-trace-id': traceId }
                    });
                    await expect(async () => await (0, error_handling_1.checkResponseError)(mockResponse)).rejects.toMatchError(new errors_1.ForgeKvsAPIError({
                        status: 404,
                        statusText: 'Not Found',
                        traceId
                    }, {
                        code: 'UNKNOWN_ERROR',
                        context: { responseText: '' },
                        message: 'Unexpected error in Forge KVS API'
                    }));
                });
                it("returns UNKNOWN_ERROR if there is a JSON body that isn't a forge error", async () => {
                    const body = JSON.stringify({ not: 'a forge error' });
                    const mockResponse = new Response(body, {
                        status: 500,
                        statusText: 'Internal Server Error',
                        headers: { 'x-trace-id': traceId }
                    });
                    await expect(async () => await (0, error_handling_1.checkResponseError)(mockResponse)).rejects.toMatchError(new errors_1.ForgeKvsAPIError({
                        status: 500,
                        statusText: 'Internal Server Error',
                        traceId
                    }, {
                        code: 'UNKNOWN_ERROR',
                        context: { responseText: body },
                        message: 'Unexpected error in Forge KVS API'
                    }));
                });
            });
        });
    });
});
