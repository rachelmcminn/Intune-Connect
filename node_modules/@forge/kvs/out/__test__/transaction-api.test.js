"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const transaction_api_1 = require("../transaction-api");
const storage_api_1 = require("../storage-api");
const xen_test_util_1 = require("@atlassian/xen-test-util");
const entity_query_1 = require("../entity-query");
const TransactionUtils = tslib_1.__importStar(require("../utils/transaction-request-builder"));
const key = 'key';
const entityName = 'entity';
const defaultEntity = { field1: 'test' };
jest.mock('../utils/transaction-request-builder');
class TestTransactionBuilderImpl extends transaction_api_1.TransactionBuilderImpl {
    getSets() {
        return this.sets;
    }
    getDeletes() {
        return this.deletes;
    }
    getChecks() {
        return this.checks;
    }
}
describe('TransactionBuilderImpl', () => {
    function setupForTests(sets = [], deletes = [], checks = []) {
        const storageApi = (0, xen_test_util_1.mock)(storage_api_1.StorageApi);
        const transactionBuilder = new TestTransactionBuilderImpl(storageApi, sets, deletes, checks);
        return { storageApi, transactionBuilder };
    }
    beforeEach(() => {
        jest.clearAllMocks();
    });
    describe('set', () => {
        it.each(['test', 100, false, [1, 2, 3], { key: 'value' }])('set should add into array of transaction set with value %s', (value) => {
            const { transactionBuilder } = setupForTests();
            transactionBuilder.set(key, value);
            expect(transactionBuilder.getSets()).toContainEqual({ key, value });
            expect(transactionBuilder.getDeletes()).toHaveLength(0);
            expect(transactionBuilder.getChecks()).toHaveLength(0);
        });
        it('set should add into array of transaction set with entity and condition', () => {
            const { transactionBuilder } = setupForTests();
            const filterBuilder = new entity_query_1.FilterBuilder();
            transactionBuilder.set(key, defaultEntity, { entityName, conditions: filterBuilder });
            expect(transactionBuilder.getSets()).toContainEqual({
                key,
                value: defaultEntity,
                entity: { entityName, conditions: filterBuilder }
            });
            expect(transactionBuilder.getDeletes()).toHaveLength(0);
            expect(transactionBuilder.getChecks()).toHaveLength(0);
        });
    });
    describe('delete', () => {
        it('delete should add into array of transaction delete', () => {
            const { transactionBuilder } = setupForTests();
            transactionBuilder.delete(key);
            expect(transactionBuilder.getDeletes()).toContainEqual({ key });
            expect(transactionBuilder.getSets()).toHaveLength(0);
            expect(transactionBuilder.getChecks()).toHaveLength(0);
        });
        it('delete should add into array of transaction delete with entity and condition', () => {
            const { transactionBuilder } = setupForTests();
            const filterBuilder = new entity_query_1.FilterBuilder();
            transactionBuilder.delete(key, { entityName, conditions: filterBuilder });
            expect(transactionBuilder.getDeletes()).toContainEqual({
                key,
                entity: { entityName, conditions: filterBuilder }
            });
            expect(transactionBuilder.getSets()).toHaveLength(0);
            expect(transactionBuilder.getChecks()).toHaveLength(0);
        });
    });
    describe('check', () => {
        it('check should add into array of transaction check with entity and condition', () => {
            const { transactionBuilder } = setupForTests();
            const filterBuilder = new entity_query_1.FilterBuilder();
            transactionBuilder.check(key, { entityName, conditions: filterBuilder });
            expect(transactionBuilder.getChecks()).toContainEqual({
                key,
                entity: { entityName, conditions: filterBuilder }
            });
            expect(transactionBuilder.getSets()).toHaveLength(0);
            expect(transactionBuilder.getDeletes()).toHaveLength(0);
        });
    });
    describe('execute', () => {
        it('should map items to request state before sending to storage api', async () => {
            const transactSet = [{ key, value: 'test' }];
            const requestSet = { key, value: 'test' };
            const transactDelete = [{ key }];
            const requestDelete = { key };
            const transactCheck = [
                { key, entity: { entityName, conditions: new entity_query_1.FilterBuilder() } }
            ];
            const requestCheck = { key, entityName, conditions: { and: [] } };
            const { storageApi, transactionBuilder } = setupForTests(transactSet, transactDelete, transactCheck);
            const buildSetSpy = jest.spyOn(TransactionUtils, 'buildRequestSet');
            buildSetSpy.mockReturnValueOnce(requestSet);
            const buildDeleteSpy = jest.spyOn(TransactionUtils, 'buildRequestDeletes');
            buildDeleteSpy.mockReturnValueOnce(requestDelete);
            const buildCheckSpy = jest.spyOn(TransactionUtils, 'buildRequestChecks');
            buildCheckSpy.mockReturnValueOnce(requestCheck);
            await transactionBuilder.execute();
            expect(buildSetSpy).toHaveBeenCalledWith(transactSet[0], 0, transactSet);
            expect(buildDeleteSpy).toHaveBeenCalledWith(transactDelete[0], 0, transactDelete);
            expect(buildCheckSpy).toHaveBeenCalledWith(transactCheck[0], 0, transactCheck);
            expect(storageApi.transact).toHaveBeenCalledWith({
                set: [requestSet],
                delete: [requestDelete],
                check: [requestCheck]
            });
        });
        it('should set undefined if no items are present', async () => {
            const { storageApi, transactionBuilder } = setupForTests();
            const buildSetSpy = jest.spyOn(TransactionUtils, 'buildRequestSet');
            const buildDeleteSpy = jest.spyOn(TransactionUtils, 'buildRequestDeletes');
            const buildCheckSpy = jest.spyOn(TransactionUtils, 'buildRequestChecks');
            await transactionBuilder.execute();
            expect(buildSetSpy).not.toHaveBeenCalled();
            expect(buildDeleteSpy).not.toHaveBeenCalled();
            expect(buildCheckSpy).not.toHaveBeenCalled();
            expect(storageApi.transact).toHaveBeenCalledWith({
                set: undefined,
                delete: undefined,
                check: undefined
            });
        });
    });
});
