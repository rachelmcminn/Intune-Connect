"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const conditions_1 = require("../conditions");
const entity_query_1 = require("../entity-query");
const errors_1 = require("../errors");
const types_1 = require("../interfaces/types");
const kvs_1 = require("../kvs");
const storage_api_1 = require("../storage-api");
function prepare(response) {
    const apiClient = jest.fn().mockResolvedValueOnce(response);
    const storageApi = new storage_api_1.StorageApi(apiClient);
    const sut = new kvs_1.KvsImpl(storageApi);
    return {
        apiClient,
        storageApi,
        sut
    };
}
describe('KVS', () => {
    const traceId = 'traceId';
    it('should get correctly', async () => {
        const response = new Response(JSON.stringify({ key: 'foo', value: 'bar' }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.get('foo');
        expect(rs).toEqual('bar');
        expect(apiClient).toHaveBeenCalledWith('/api/v1/get', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should return undefined when get receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.get('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/get', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should handle unexpected response', async () => {
        const response = new Response(JSON.stringify({ code: 'INTERNAL_SERVER_ERROR', message: 'An internal server error has occurred' }), {
            status: 500,
            statusText: 'Internal Server Error',
            headers: { 'x-trace-id': traceId }
        });
        const { sut } = prepare(response);
        await expect(sut.get('foo')).rejects.toMatchError(new errors_1.ForgeKvsAPIError({ status: 500, statusText: 'Internal Server Error', traceId }, { code: 'INTERNAL_SERVER_ERROR', message: 'An internal server error has occurred' }));
    });
    it('should handle non-json response even though status is ok', async () => {
        const response = new Response('Some non JSON response that will fail to parse', {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut } = prepare(response);
        await expect(sut.get('foo')).rejects.toMatchError(new errors_1.ForgeKvsError('Unexpected error. Response was not valid JSON: Some non JSON response that will fail to parse'));
    });
    it('should getSecret correctly', async () => {
        const response = new Response(JSON.stringify({ key: 'foo', value: 'bar' }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.getSecret('foo');
        expect(rs).toEqual('bar');
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/get', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should return undefined when getSecret receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.getSecret('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/get', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should getEntity correctly', async () => {
        const response = new Response(JSON.stringify({ key: 'foo', value: { name: 'Jane Doe' } }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').get('foo');
        expect(rs).toEqual({ name: 'Jane Doe' });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/get', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo' })
        }));
    });
    it('should return undefined when getEntity receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').get('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/get', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo' })
        }));
    });
    it('should set correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.set('foo', 'bar');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/set', expect.objectContaining({
            body: JSON.stringify({ key: 'foo', value: 'bar' })
        }));
    });
    it('should setSecret correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.setSecret('foo', 'bar');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/set', expect.objectContaining({
            body: JSON.stringify({ key: 'foo', value: 'bar' })
        }));
    });
    it('should setEntity correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').set('foo', { name: 'Jane Doe' });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/set', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo', value: { name: 'Jane Doe' } })
        }));
    });
    it('should delete correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.delete('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/delete', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should return undefined when delete receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.delete('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/delete', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should deleteSecret correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.deleteSecret('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/delete', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should return undefined when deleteSecret receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.deleteSecret('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/delete', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should deleteEntity correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').delete('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/delete', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo' })
        }));
    });
    it('should return undefined when deleteEntity receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').delete('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/delete', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo' })
        }));
    });
    it('should query correctly', async () => {
        const response = new Response(JSON.stringify({ cursor: 'third-page', data: [{ key: 'foo', value: 'bar' }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .query()
            .cursor('second-page')
            .limit(1)
            .where('key', conditions_1.WhereConditions.beginsWith('fo'))
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: 'bar' }],
            nextCursor: 'third-page'
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/query', expect.objectContaining({
            body: JSON.stringify({
                limit: 1,
                after: 'second-page',
                where: [{ property: 'key', condition: 'BEGINS_WITH', values: ['fo'] }]
            })
        }));
    });
    it('should getOne out of a list of results', async () => {
        const response = new Response(JSON.stringify({
            data: [
                { key: 'foo', value: 'bar' },
                { key: 'bar', value: 'foo' }
            ]
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.query().getOne();
        expect(rs).toEqual({ key: 'foo', value: 'bar' });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/query', expect.objectContaining({
            body: JSON.stringify({ limit: 1 })
        }));
    });
    it('should default to undefined when getOne receives an empty list', async () => {
        const response = new Response(JSON.stringify({ data: [] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.query().getOne();
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/query', expect.objectContaining({
            body: JSON.stringify({ limit: 1 })
        }));
    });
    it('should query entity correctly and pass partition with index', async () => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-employmentyear', { partition: [2000] })
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-employmentyear',
                partition: [2000]
            })
        }));
    });
    it('should query entity correctly (without any filters)', async () => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .sort(types_1.Sort.ASC)
            .limit(100)
            .cursor('second-page')
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                sort: 'ASC',
                limit: 100,
                cursor: 'second-page'
            })
        }));
    });
    it('should query entity correctly (with "or" filters)', async () => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const filter = new entity_query_1.FilterBuilder()
            .or('age', conditions_1.FilterConditions.greaterThan(30))
            .or('age', conditions_1.FilterConditions.lessThan(35));
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .filters(filter)
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                filters: {
                    or: [
                        { property: 'age', condition: 'GREATER_THAN', values: [30] },
                        { property: 'age', condition: 'LESS_THAN', values: [35] }
                    ]
                }
            })
        }));
    });
    it('should query entity correctly (with "and" filters)', async () => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .filters(new entity_query_1.FilterBuilder()
            .and('age', conditions_1.FilterConditions.greaterThan(30))
            .and('employmentyear', conditions_1.FilterConditions.lessThan(2000)))
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                filters: {
                    and: [
                        { property: 'age', condition: 'GREATER_THAN', values: [30] },
                        { property: 'employmentyear', condition: 'LESS_THAN', values: [2000] }
                    ]
                }
            })
        }));
    });
    it('should getOne entity out of a list', async () => {
        const response = new Response(JSON.stringify({
            data: [
                { key: 'foo', value: { name: 'Jane Foo' } },
                { key: 'bar', value: { name: 'Jane Bar' } }
            ]
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .getOne();
        expect(rs).toEqual({ key: 'foo', value: { name: 'Jane Foo' } });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                limit: 1
            })
        }));
    });
    it('should default to undefined when getOne entity receives an empty list', async () => {
        const response = new Response(JSON.stringify({ data: [] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .getOne();
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                limit: 1
            })
        }));
    });
    it.each([
        {
            title: 'between',
            condition: conditions_1.WhereConditions.between(10, 20),
            expectedPayload: { condition: 'BETWEEN', values: [10, 20] }
        },
        {
            title: 'beginsWith',
            condition: conditions_1.WhereConditions.beginsWith('foo'),
            expectedPayload: { condition: 'BEGINS_WITH', values: ['foo'] }
        },
        {
            title: 'equalTo',
            condition: conditions_1.WhereConditions.equalTo('foo'),
            expectedPayload: { condition: 'EQUAL_TO', values: ['foo'] }
        },
        {
            title: 'greaterThan',
            condition: conditions_1.WhereConditions.greaterThan(10),
            expectedPayload: { condition: 'GREATER_THAN', values: [10] }
        },
        {
            title: 'greaterThanEqualTo',
            condition: conditions_1.WhereConditions.greaterThanEqualTo(10),
            expectedPayload: { condition: 'GREATER_THAN_EQUAL_TO', values: [10] }
        },
        {
            title: 'lessThan',
            condition: conditions_1.WhereConditions.lessThan(10),
            expectedPayload: { condition: 'LESS_THAN', values: [10] }
        },
        {
            title: 'lessThanEqualTo',
            condition: conditions_1.WhereConditions.lessThanEqualTo(10),
            expectedPayload: { condition: 'LESS_THAN_EQUAL_TO', values: [10] }
        }
    ])('should test $title all where conditions', async ({ condition, expectedPayload }) => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').query().index('by-key').where(condition).getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: expectedPayload
            })
        }));
    });
    it.each([
        {
            title: 'between',
            condition: conditions_1.FilterConditions.between(10, 20),
            expectedPayload: { condition: 'BETWEEN', values: [10, 20] }
        },
        {
            title: 'beginsWith',
            condition: conditions_1.FilterConditions.beginsWith('foo'),
            expectedPayload: { condition: 'BEGINS_WITH', values: ['foo'] }
        },
        { title: 'exists', condition: conditions_1.FilterConditions.exists(), expectedPayload: { condition: 'EXISTS', values: [true] } },
        {
            title: 'notExists',
            condition: conditions_1.FilterConditions.notExists(),
            expectedPayload: { condition: 'NOT_EXISTS', values: [true] }
        },
        {
            title: 'greaterThan',
            condition: conditions_1.FilterConditions.greaterThan(10),
            expectedPayload: { condition: 'GREATER_THAN', values: [10] }
        },
        {
            title: 'greaterThanEqualTo',
            condition: conditions_1.FilterConditions.greaterThanEqualTo(10),
            expectedPayload: { condition: 'GREATER_THAN_EQUAL_TO', values: [10] }
        },
        {
            title: 'lessThan',
            condition: conditions_1.FilterConditions.lessThan(10),
            expectedPayload: { condition: 'LESS_THAN', values: [10] }
        },
        {
            title: 'lessThanEqualTo',
            condition: conditions_1.FilterConditions.lessThanEqualTo(10),
            expectedPayload: { condition: 'LESS_THAN_EQUAL_TO', values: [10] }
        },
        {
            title: 'contains',
            condition: conditions_1.FilterConditions.contains('foo'),
            expectedPayload: { condition: 'CONTAINS', values: ['foo'] }
        },
        {
            title: 'notContains',
            condition: conditions_1.FilterConditions.notContains('foo'),
            expectedPayload: { condition: 'NOT_CONTAINS', values: ['foo'] }
        },
        {
            title: 'equalTo',
            condition: conditions_1.FilterConditions.equalTo('foo'),
            expectedPayload: { condition: 'EQUAL_TO', values: ['foo'] }
        },
        {
            title: 'notEqualTo',
            condition: conditions_1.FilterConditions.notEqualTo('foo'),
            expectedPayload: { condition: 'NOT_EQUAL_TO', values: ['foo'] }
        }
    ])('should test $title all filter conditions', async ({ condition, expectedPayload }) => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .filters(new entity_query_1.FilterBuilder().and('name', condition))
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                filters: {
                    and: [{ property: 'name', ...expectedPayload }]
                }
            })
        }));
    });
    it('should sumbit transaction correctly', async () => {
        const response = new Response(undefined, {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        await sut.transact().set('foo', 'bar').delete('bar').execute();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/transaction', expect.objectContaining({
            body: JSON.stringify({
                set: [{ key: 'foo', value: 'bar' }],
                delete: [{ key: 'bar' }]
            })
        }));
    });
});
