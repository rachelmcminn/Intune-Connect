"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageApi = void 0;
const error_handling_1 = require("./utils/error-handling");
const errors_1 = require("./errors");
class StorageApi {
    apiClient;
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    async get(body) {
        const rs = await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/get', body, true);
        });
        return rs?.value;
    }
    async getSecret(body) {
        const rs = await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/secret/get', body, true);
        });
        return rs?.value;
    }
    async getEntity(body) {
        const rs = await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/entity/get', body, true);
        });
        return rs?.value;
    }
    async set(body) {
        await this.request('/api/v1/set', body, false);
    }
    async setSecret(body) {
        await this.request('/api/v1/secret/set', body, false);
    }
    async setEntity(body) {
        await this.request('/api/v1/entity/set', body, false);
    }
    async delete(body) {
        await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/delete', body, false);
        });
    }
    async deleteSecret(body) {
        await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/secret/delete', body, false);
        });
    }
    async deleteEntity(body) {
        await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/entity/delete', body, false);
        });
    }
    async query(body) {
        const rs = await this.request('/api/v1/query', body, true);
        return {
            results: rs.data,
            nextCursor: rs.cursor
        };
    }
    async queryEntity(body) {
        const rs = await this.request('/api/v1/entity/query', body, true);
        return {
            results: rs.data,
            nextCursor: rs.cursor
        };
    }
    async transact(transactionRequest) {
        await this.request('/api/v1/transaction', transactionRequest, false);
    }
    async handleKeyNotFound(fn) {
        try {
            return await fn();
        }
        catch (e) {
            if (e instanceof errors_1.ForgeKvsAPIError && e.code === 'KEY_NOT_FOUND') {
                return undefined;
            }
            throw e;
        }
    }
    async request(path, body, isResponseExpected) {
        const requestBody = {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'content-type': 'application/json'
            }
        };
        const response = await this.apiClient(path, requestBody);
        await (0, error_handling_1.checkResponseError)(response);
        if (!isResponseExpected) {
            return {};
        }
        const responseText = await response.text();
        try {
            return JSON.parse(responseText);
        }
        catch (error) {
            throw new errors_1.ForgeKvsError(`Unexpected error. Response was not valid JSON: ${responseText}`);
        }
    }
}
exports.StorageApi = StorageApi;
