/* index.tsx generated by @compiled/babel-plugin v0.36.1 */
"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cx = exports.cssMap = exports.css = void 0;
Object.defineProperty(exports, "jsx", {
  enumerable: true,
  get: function get() {
    return _react2.jsx;
  }
});
var React = _interopRequireWildcard(require("react"));
var _runtime = require("@compiled/react/runtime");
var _react2 = require("@compiled/react");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var _createStrictAPI = (0, _react2.createStrictAPI)(),
  XCSSProp = _createStrictAPI.XCSSProp,
  css = exports.css = _createStrictAPI.css,
  cssMap = exports.cssMap = _createStrictAPI.cssMap,
  cx = exports.cx = _createStrictAPI.cx;

// This is to mitigate local TS error TS2315: Type 'StrictXCSSProp' is not generic.
// Currently for some reason tsc is generating malformed .d.ts in local dev environment, below change fixes it

/**
 * ## StrictXCSSProp
 *
 * Declare styles your component takes with all other styles marked as violations
 * by the TypeScript compiler. There are two primary use cases for xcss prop:
 *
 * - safe style overrides
 * - inverting style declarations
 *
 * Interverting style declarations is interesting for platform teams as
 * it means products only pay for styles they use as they're now the ones who declare
 * the styles!
 *
 * The {@link StrictXCSSProp} type has generics two of which must be defined â€” use to explicitly
 * set what you want to maintain as API. Use {@link XCSSAllProperties} and {@link XCSSAllPseudos}
 * to enable all properties and pseudos.
 *
 * The third generic is used to declare what properties and pseudos should be required.
 *
 * ```tsx
 * interface MyComponentProps {
 *   // Color is accepted, all other properties / pseudos are considered violations.
 *   xcss?: StrictXCSSProp<'color', never>;
 *
 *   // Only background color and hover pseudo are accepted.
 *   xcss?: StrictXCSSProp<'backgroundColor', '&:hover'>;
 *
 *   // All properties are accepted, all pseudos are considered violations.
 *   xcss?: StrictXCSSProp<XCSSAllProperties, never>;
 *
 *   // All properties are accepted, only the hover pseudo is accepted.
 *   xcss?: StrictXCSSProp<XCSSAllProperties, '&:hover'>;
 *
 *   // The xcss prop is required as well as the color property. No pseudos are required.
 *   xcss: StrictXCSSProp<
 *     XCSSAllProperties,
 *     '&:hover',
 *     { requiredProperties: 'color', requiredPseudos: never }
 *   >;
 * }
 *
 * function MyComponent({ xcss }: MyComponentProps) {
 *   return <div css={{ color: 'var(--ds-text-danger)' }} className={xcss} />
 * }
 * ```
 *
 * The xcss prop works with static inline objects and the [cssMap](https://compiledcssinjs.com/docs/api-cssmap) API.
 *
 * ```jsx
 * // Declared as an inline object
 * <Component xcss={{ color: 'var(--ds-text)' }} />
 *
 * // Declared with the cssMap API
 * const styles = cssMap({ text: { color: 'var(--ds-text)' } });
 * <Component xcss={styles.text} />
 * ```
 *
 * To concatenate and conditonally apply styles use the {@link cssMap} and {@link cx} functions.
 */